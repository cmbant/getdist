name: Build Mac App

on:
  workflow_dispatch:
    inputs:
      skip_signing:
        description: 'Skip signing and notarization (for testing only)'
        required: false
        default: false
        type: boolean
  push:
    branches: [ main, master, mac ]
    paths:
      - 'getdist/gui/**'
      - 'scripts/build_mac_app.py'
      - 'scripts/build_mac_app.sh'
      - '.github/workflows/build_mac_app.yml'

jobs:
  build:
    runs-on: macos-latest

    steps:
    - uses: actions/checkout@v4

    - name: Set up Python
      uses: actions/setup-python@v5
      with:
        python-version: '3.10'

    - name: Install uv
      run: |
        curl -LsSf https://astral.sh/uv/install.sh | sh
        echo "$HOME/.cargo/bin" >> $GITHUB_PATH
        # Verify uv installation
        source "$HOME/.cargo/env"
        uv --version

    - name: Build Mac App
      run: |
        # Make the script executable
        chmod +x scripts/build_mac_app.sh
        # Show environment info
        echo "Python version:"
        python --version
        echo "uv version:"
        uv --version
        echo "Working directory:"
        pwd
        # Run the build script with verbose output
        ./scripts/build_mac_app.sh

    - name: Prepare App Bundle for Signing
      if: github.event.inputs.skip_signing != 'true'
      run: |
        # Rename app bundle to remove spaces
        echo "Renaming app bundle to remove spaces..."
        mv "dist/GetDist GUI.app" "dist/GetDistGUI.app"

        # Create a temporary directory for the certificate
        CERT_PATH=$RUNNER_TEMP/certificate.p12
        KEYCHAIN_PATH=$RUNNER_TEMP/app-signing.keychain-db

        # Decode and save the certificate
        echo "Decoding certificate..."
        echo "${{ secrets.MACOS_CERTIFICATE }}" | base64 --decode > $CERT_PATH

        # Create a temporary keychain
        echo "Creating temporary keychain..."
        security create-keychain -p "temp-password" $KEYCHAIN_PATH
        security set-keychain-settings -lut 21600 $KEYCHAIN_PATH
        security unlock-keychain -p "temp-password" $KEYCHAIN_PATH

        # Import certificate to keychain
        echo "Importing certificate to keychain..."
        security import $CERT_PATH -P "${{ secrets.MACOS_CERTIFICATE_PWD }}" -A -t cert -f pkcs12 -k $KEYCHAIN_PATH
        security list-keychain -d user -s $KEYCHAIN_PATH

        # Allow codesign to access the keychain
        security set-key-partition-list -S apple-tool:,apple:,codesign: -s -k "temp-password" $KEYCHAIN_PATH

        # Find the identity
        echo "Available signing identities:"
        IDENTITY=$(security find-identity -v -p codesigning | grep "Developer ID Application" | head -1 | sed -E 's/.*"(Developer ID Application: .+)"$/\1/')
        echo "Using identity: $IDENTITY"

        # Create entitlements file
        echo "Creating entitlements file..."
        echo '<?xml version="1.0" encoding="UTF-8"?>' > entitlements.plist
        echo '<!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">' >> entitlements.plist
        echo '<plist version="1.0">' >> entitlements.plist
        echo '<dict>' >> entitlements.plist
        echo '    <key>com.apple.security.cs.allow-jit</key>' >> entitlements.plist
        echo '    <true/>' >> entitlements.plist
        echo '    <key>com.apple.security.cs.allow-unsigned-executable-memory</key>' >> entitlements.plist
        echo '    <true/>' >> entitlements.plist
        echo '    <key>com.apple.security.cs.disable-library-validation</key>' >> entitlements.plist
        echo '    <true/>' >> entitlements.plist
        echo '    <key>com.apple.security.cs.allow-dyld-environment-variables</key>' >> entitlements.plist
        echo '    <true/>' >> entitlements.plist
        echo '    <key>com.apple.security.automation.apple-events</key>' >> entitlements.plist
        echo '    <true/>' >> entitlements.plist
        echo '</dict>' >> entitlements.plist
        echo '</plist>' >> entitlements.plist

        # Sign the app with special handling for Qt frameworks
        echo "Signing app bundle with hardened runtime..."

        # First, sign all the Qt frameworks individually
        echo "Signing Qt frameworks..."
        find "dist/GetDistGUI.app/Contents/Frameworks" -type f -name "*.dylib" -o -name "*.so" | while read -r file; do
            echo "Signing $file"
            codesign --force --verify --verbose --options runtime --entitlements entitlements.plist --sign "$IDENTITY" "$file"
        done

        # Sign any framework bundles
        find "dist/GetDistGUI.app/Contents/Frameworks" -type d -name "*.framework" | while read -r framework; do
            echo "Signing framework: $framework"
            codesign --force --verify --verbose --options runtime --entitlements entitlements.plist --sign "$IDENTITY" "$framework"
        done

        # Sign the main executable
        echo "Signing main executable..."
        codesign --force --verify --verbose --options runtime --entitlements entitlements.plist --sign "$IDENTITY" "dist/GetDistGUI.app/Contents/MacOS/GetDistGUI"

        # Finally sign the app bundle
        echo "Signing app bundle..."
        codesign --force --verify --verbose --options runtime --entitlements entitlements.plist --sign "$IDENTITY" "dist/GetDistGUI.app"

        # Verify signature
        echo "Verifying app signature..."
        codesign --verify --verbose "dist/GetDistGUI.app"

        # Verify with strict validation
        echo "Verifying with strict validation..."
        codesign --verify --verbose=4 --strict "dist/GetDistGUI.app"

        # Check for specific issues with frameworks
        echo "Checking for framework issues..."
        codesign --verify --verbose "dist/GetDistGUI.app/Contents/Frameworks/PySide6/Qt/lib/QtQuick.framework"

        # Create a ZIP archive for notarization
        echo "Creating ZIP archive for notarization..."
        ditto -c -k --keepParent "dist/GetDistGUI.app" "dist/GetDistGUI.zip"

        # Set up App Store Connect API
        echo "Setting up App Store Connect API..."
        mkdir -p ~/private_keys
        echo '${{ secrets.APP_STORE_CONNECT_KEY }}' > ~/private_keys/AuthKey_${{ secrets.APP_STORE_CONNECT_API_KEY }}.p8

        # Submit for notarization
        echo "Submitting app for notarization..."
        NOTARIZATION_UUID=$(xcrun notarytool submit "dist/GetDistGUI.zip" \
          --key ~/private_keys/AuthKey_${{ secrets.APP_STORE_CONNECT_API_KEY }}.p8 \
          --key-id ${{ secrets.APP_STORE_CONNECT_API_KEY }} \
          --issuer ${{ secrets.APP_STORE_CONNECT_API_ISSUER }} \
          --wait | grep "id:" | awk '{print $2}')

        echo "Notarization UUID: $NOTARIZATION_UUID"

        # Check notarization status
        echo "Checking notarization status..."
        xcrun notarytool info "$NOTARIZATION_UUID" \
          --key ~/private_keys/AuthKey_${{ secrets.APP_STORE_CONNECT_API_KEY }}.p8 \
          --key-id ${{ secrets.APP_STORE_CONNECT_API_KEY }} \
          --issuer ${{ secrets.APP_STORE_CONNECT_API_ISSUER }}

        # Get detailed log
        echo "Getting detailed notarization log..."
        xcrun notarytool log "$NOTARIZATION_UUID" \
          --key ~/private_keys/AuthKey_${{ secrets.APP_STORE_CONNECT_API_KEY }}.p8 \
          --key-id ${{ secrets.APP_STORE_CONNECT_API_KEY }} \
          --issuer ${{ secrets.APP_STORE_CONNECT_API_ISSUER }} \
          notarization.log

        cat notarization.log

        # Staple the notarization ticket
        echo "Stapling notarization ticket to app..."
        xcrun stapler staple "dist/GetDistGUI.app"

        # Verify stapling
        echo "Verifying stapling..."
        stapler validate "dist/GetDistGUI.app"

    - name: Create DMG with Signed App
      if: github.event.inputs.skip_signing != 'true'
      run: |
        # Create a DMG with the signed and notarized app
        echo "Creating DMG with signed app..."
        # Create a temporary directory for the DMG contents
        mkdir -p "dist/dmg"
        # Copy the signed and notarized app bundle to the temporary directory
        cp -r "dist/GetDistGUI.app" "dist/dmg/GetDist GUI.app"
        # Create a symlink to the Applications folder
        ln -s /Applications "dist/dmg/"
        # Create the DMG
        hdiutil create -volname "GetDist GUI" -srcfolder "dist/dmg" -ov -format UDZO "dist/GetDist-GUI.dmg"
        # Clean up
        rm -rf "dist/dmg"

        echo "Verifying app signature..."
        codesign --verify --verbose "dist/GetDistGUI.app"
        echo "Verifying app notarization..."
        spctl --assess --verbose=4 "dist/GetDistGUI.app"

    - name: Upload DMG
      uses: actions/upload-artifact@v4
      with:
        name: GetDist-GUI-DMG
        path: dist/GetDist-GUI.dmg

    - name: Create Release (on tag)
      if: startsWith(github.ref, 'refs/tags/')
      uses: softprops/action-gh-release@v2
      with:
        files: |
          dist/GetDist-GUI.dmg
        draft: true
        prerelease: false
